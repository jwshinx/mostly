#!/usr/bin/env ruby
require 'gli'
require 'yaml'
begin # XXX: Remove this begin/rescue before distributing your app
require 'fix'
require 'nokogiri'
require 'open-uri'

rescue LoadError
  STDERR.puts "In development, you need to use `bundle exec bin/fix` to run your app"
  STDERR.puts "At install-time, RubyGems will make sure lib, etc. are in the load path"
  STDERR.puts "Feel free to remove this message from bin/fix now"
  exit 64
end

include GLI::App

program_desc 'Generate a message for a fix!'

version Fix::VERSION

# Use argument validation
arguments :strict

desc 'Describe some switch here'
switch [:s,:switch]

desc 'Enter sassy value -- 1 being most, 5 least'
default_value '5'
arg_name 'The name of the argument'
flag [:f,:flagname]

desc 'create a message'
arg_name 'List of adjectives'

@intros = []
@sents = []
@para = []
@used_indeces = {}
@nbr = Random.rand(100)

@stuff = YAML.load_file('../config.yml')

command :create do |c|
  c.desc 'Denote new customer with -n. Leave out for returning customer.'
  c.switch :n

  c.desc 'Day type.'
  c.default_value 'great'
  c.flag :f
  c.action do |global_options,options,args|
    print_options global_options,options,args
    puts "--- create --------------------"

    # think about making this command create_sassy or create_homely
    # pass in args as variable to describe products
    # other flags for what?
    # how do i template?  vintage -> certain lists
    # return customer flag, first timer, hard to please

    @intros_new = populate_intros_new("intro.txt") #{ |line| @intros << line }
    @intros_returning = populate_intros_returning("intro.txt") #{ |line| @intros << line }

    @closings_new = populate_closings_new("closing.txt") #{ |line| @intros << line }
    @closings_returning = populate_closings_returning("closing.txt") #{ |line| @intros << line }

    populate_collection("item_sentence.txt") { |line| @sents << line }
    
    choose_para_intro options[:n]
    choose_para_sentences
    choose_para_closing options[:n], options[:f]
    
    display_result
  end
end

desc 'initial load of all existing messages'
arg_name 'load adjectives'
command :load do |c|
  c.desc 'Describe a switch to load'
  c.switch :s

  c.desc 'Describe a flag to load'
  c.default_value 'default'
  c.flag :f
  c.action do |global_options,options,args|
    all_msgs = []
    doc = Nokogiri::HTML(open('https://www.thredup.com/team'))
    doc.css('p.bio').each do |p|
      #puts "#{p.content.to_s}" + "\n\n"
      msg = []
      p.content.split('.').each { |sentence| msg << sentence.strip + '.' }
      all_msgs << msg
    end

    begin
      open("messages.txt", "w") do |f|
        all_msgs.each do |msg|
          msg.each do |sentence|
            f << sentence + "\n"
          end
        end
      end
    rescue => err
      puts "Exception writing messages.txt: #{err}"
      raise "Exception writing messages.txt: #{err}"
    end  
    
    print_options global_options,options,args
    #puts "all msgs: #{all_msgs.inspect}"
    puts "load command ran"
  end
end


desc 'list spits out all the stuff'
arg_name 'Customer adjectives'
command :list do |c|
  c.desc 'Describe a switch to list'
  c.switch :s

  c.desc 'Describe a flag to list'
  c.default_value 'default'
  c.flag :f
  c.action do |global_options,options,args|
    # Your command logic here     
    # If you have any errors, just raise them
    # raise "that command made no sense"
    print_options global_options,options,args
    puts "list command ran"
  end
end

desc 'add creates another entry'
arg_name 'Describe arguments to add here'
command :add do |c|
  c.action do |global_options,options,args|
    puts "add command ran"
  end
end

desc 'done denotes that you can go home'
arg_name 'Describe arguments to done here'
command :done do |c|
  c.action do |global_options,options,args|
    puts "done command ran"
  end
end

pre do |global,command,options,args|
  # Pre logic here
  # Return true to proceed; false to abort and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling
  true
  #false
end

def display_result
  puts "\n\n--- results ---"
  puts @para.join("\n")
  puts "\n\n"
end

def choose_para_sentences
  @para << make_sent( 'item1', @sents ) if @stuff['customer'].has_key?('item1')
  @para << make_sent( 'item2', @sents ) if @stuff['customer'].has_key?('item2')
  @para << make_sent( 'item3', @sents ) if @stuff['customer'].has_key?('item3')
  @para << make_sent( 'item4', @sents ) if @stuff['customer'].has_key?('item4')
  @para << make_sent( 'item5', @sents ) if @stuff['customer'].has_key?('item5')
end

def choose_para_intro isnew
  intro = if isnew
    @intros_new[@nbr%(@intros_new.length) - 1]
  else
    @intros_returning[@nbr%(@intros_returning.length) - 1]
  end
  @para << intro.gsub('[customer]', @stuff['customer']['name'])
end

def choose_para_closing isnew, value
  closing = if isnew
    @closings_new[@nbr%(@closings_new.length) - 1]
  else
    @closings_returning[@nbr%(@closings_returning.length) - 1]
  end
  @para << closing.gsub('[day-type]', value)
end

def generate_index collection_length
  nbr = Random.rand(100)
  nbr%(collection_length-1)
end

def make_sent key, sents
  index = generate_index sents.length
  while @used_indeces.has_key?(index.to_s) do
    index = generate_index sents.length 
  end
  @used_indeces[index.to_s] = 1

  puts "---> index: #{index.to_s}"
  @sent = @sents[index]
  mysent = @sent.gsub('[color]', @stuff['customer'][key]['color'])
  mysent = mysent.gsub('[item]', @stuff['customer'][key]['name'])
  mysent
end

def populate_intros_new filename
  arr = []
  begin
    file = File.new("../#{filename}", "r")
    while (line = file.gets)
      #yield(line.strip)
      if line.strip.split("::")[0].strip == 'NEW'
        arr << line.strip.split("::")[1]
        #puts "new....#{@intros.inspect}"
      end      
    end
    file.close
  rescue => err
    puts "Exception reading #{filename}: #{err}"
    raise "Exception reading #{filename}: #{err}"
  end
  #puts "gaa new #{arr.inspect}"
  arr  
end

def populate_intros_returning filename
  arr = []
  begin
    file = File.new("../#{filename}", "r")
    while (line = file.gets)
      #yield(line.strip)
      if line.strip.split("::")[0].strip == 'RETURNING'
        arr << line.strip.split("::")[1]
        #puts "returning....#{@intros.inspect}"        
      end
    end
    file.close
  rescue => err
    puts "Exception reading #{filename}: #{err}"
    raise "Exception reading #{filename}: #{err}"
  end
  #puts "gaa returning #{arr.inspect}"
  arr  
end

def populate_closings_new filename
  arr = []
  begin
    file = File.new("../#{filename}", "r")
    while (line = file.gets)
      if line.strip.split("::")[0].strip == 'NEW'
        arr << line.strip.split("::")[1]
      end      
    end
    file.close
  rescue => err
    puts "Exception reading #{filename}: #{err}"
    raise "Exception reading #{filename}: #{err}"
  end
  arr  
end

def populate_closings_returning filename
  arr = []
  begin
    file = File.new("../#{filename}", "r")
    while (line = file.gets)
      if line.strip.split("::")[0].strip == 'RETURNING'
        arr << line.strip.split("::")[1]
      end
    end
    file.close
  rescue => err
    puts "Exception reading #{filename}: #{err}"
    raise "Exception reading #{filename}: #{err}"
  end
  arr  
end




def populate_collection filename
  begin
    file = File.new("../#{filename}", "r")
    while (line = file.gets)
      yield(line.strip)
      #@intros << line.strip
    end
    file.close
  rescue => err
    puts "Exception reading #{filename}: #{err}"
    raise "Exception reading #{filename}: #{err}"
  end  
end

def print_options global_options,options,args
  puts "1. Global: #{global_options.inspect}"
  puts "2. Options: #{options.inspect}"
  puts "3. Args: #{args.inspect}"
end


exit run(ARGV)
